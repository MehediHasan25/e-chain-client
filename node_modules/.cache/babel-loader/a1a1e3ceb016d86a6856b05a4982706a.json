{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/mehedi/Documents/e-newclient_v-2/e-chain-client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst DeepEqual = require('./deep-equal');\n\nconst Escape = require('./escape');\n\nconst Types = require('./types');\n\nconst internals = {\n  needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n}; // Deep object or array comparison\n\nexports.deepEqual = DeepEqual; // Clone object or array\n\nexports.clone = function (obj, options = {}, _seen = null) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  let clone = exports.clone;\n  let seen = _seen;\n\n  if (options.shallow) {\n    if (options.shallow !== true) {\n      return internals.cloneWithShallow(obj, options);\n    }\n\n    clone = value => value;\n  } else {\n    seen = seen || new Map();\n    const lookup = seen.get(obj);\n\n    if (lookup) {\n      return lookup;\n    }\n  }\n\n  const baseProto = Types.getInternalProto(obj);\n  let newObj;\n\n  switch (baseProto) {\n    case Types.buffer:\n      return Buffer.from(obj);\n\n    case Types.date:\n      return new Date(obj.getTime());\n\n    case Types.regex:\n      return new RegExp(obj);\n\n    case Types.array:\n      newObj = [];\n      break;\n\n    default:\n      if (options.prototype !== false) {\n        // Defaults to true\n        const proto = Object.getPrototypeOf(obj);\n\n        if (proto && proto.isImmutable) {\n          return obj;\n        }\n\n        if (internals.needsProtoHack.has(baseProto)) {\n          newObj = new proto.constructor();\n\n          if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n          }\n        } else {\n          newObj = Object.create(proto);\n        }\n      } else if (internals.needsProtoHack.has(baseProto)) {\n        newObj = new baseProto.constructor();\n      } else {\n        newObj = {};\n      }\n\n  }\n\n  if (seen) {\n    seen.set(obj, newObj); // Set seen, since obj could recurse\n  }\n\n  if (baseProto === Types.set) {\n    for (const value of obj) {\n      newObj.add(clone(value, options, seen));\n    }\n  } else if (baseProto === Types.map) {\n    for (const _ref of obj) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const key = _ref2[0];\n      const value = _ref2[1];\n      newObj.set(key, clone(value, options, seen));\n    }\n  }\n\n  const keys = internals.keys(obj, options);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (baseProto === Types.array && key === 'length') {\n      continue;\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (descriptor && (descriptor.get || descriptor.set)) {\n      Object.defineProperty(newObj, key, descriptor);\n    } else {\n      Object.defineProperty(newObj, key, {\n        enumerable: descriptor ? descriptor.enumerable : true,\n        writable: true,\n        configurable: true,\n        value: clone(obj[key], options, seen)\n      });\n    }\n  }\n\n  if (baseProto === Types.array) {\n    newObj.length = obj.length;\n  }\n\n  return newObj;\n};\n\ninternals.keys = function (obj, options = {}) {\n  return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj); // Defaults to true\n};\n\ninternals.cloneWithShallow = function (source, options) {\n  const keys = options.shallow;\n  options = Object.assign({}, options);\n  options.shallow = false;\n  const storage = internals.store(source, keys); // Move shallow copy items to storage\n\n  const copy = exports.clone(source, options); // Deep copy the rest\n\n  internals.restore(copy, source, storage); // Shallow copy the stored items and restore\n\n  return copy;\n};\n\ninternals.store = function (source, keys) {\n  const storage = new Map();\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const value = exports.reach(source, key);\n\n    if (typeof value === 'object' || typeof value === 'function') {\n      storage.set(key, value);\n      internals.reachSet(source, key, undefined);\n    }\n  }\n\n  return storage;\n};\n\ninternals.restore = function (copy, source, storage) {\n  for (const _ref3 of storage) {\n    var _ref4 = _slicedToArray(_ref3, 2);\n\n    const key = _ref4[0];\n    const value = _ref4[1];\n    internals.reachSet(copy, key, value);\n    internals.reachSet(source, key, value);\n  }\n};\n\ninternals.reachSet = function (obj, key, value) {\n  const path = Array.isArray(key) ? key : key.split('.');\n  let ref = obj;\n\n  for (let i = 0; i < path.length; ++i) {\n    const segment = path[i];\n\n    if (i + 1 === path.length) {\n      ref[segment] = value;\n    }\n\n    ref = ref[segment];\n  }\n}; // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n\nexports.merge = function (target, source, options) {\n  exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n  exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n  if (!source) {\n    return target;\n  }\n\n  options = Object.assign({\n    nullOverride: true,\n    mergeArrays: true\n  }, options);\n\n  if (Array.isArray(source)) {\n    exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n\n    if (!options.mergeArrays) {\n      target.length = 0; // Must not change target assignment\n    }\n\n    for (let i = 0; i < source.length; ++i) {\n      target.push(exports.clone(source[i], {\n        symbols: options.symbols\n      }));\n    }\n\n    return target;\n  }\n\n  const keys = internals.keys(source, options);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (key === '__proto__' || !Object.prototype.propertyIsEnumerable.call(source, key)) {\n      continue;\n    }\n\n    const value = source[key];\n\n    if (value && typeof value === 'object') {\n      if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {\n        target[key] = exports.clone(value, {\n          symbols: options.symbols\n        });\n      } else {\n        exports.merge(target[key], value, options);\n      }\n    } else {\n      if (value !== null && value !== undefined) {\n        // Explicit to preserve empty strings\n        target[key] = value;\n      } else if (options.nullOverride) {\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}; // Apply source to a copy of the defaults\n\n\nexports.applyToDefaults = function (defaults, source, options = {}) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');\n  exports.assert(typeof options === 'object', 'Invalid options: must be an object');\n\n  if (!source) {\n    // If no source, return null\n    return null;\n  }\n\n  if (options.shallow) {\n    return internals.applyToDefaultsWithShallow(defaults, source, options);\n  }\n\n  const copy = exports.clone(defaults);\n\n  if (source === true) {\n    // If source is set to true, use defaults\n    return copy;\n  }\n\n  const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;\n  return exports.merge(copy, source, {\n    nullOverride,\n    mergeArrays: false\n  });\n};\n\ninternals.applyToDefaultsWithShallow = function (defaults, source, options) {\n  const keys = options.shallow;\n  exports.assert(Array.isArray(keys), 'Invalid keys');\n  options = Object.assign({}, options);\n  options.shallow = false;\n  const copy = exports.clone(defaults, {\n    shallow: keys\n  });\n\n  if (source === true) {\n    // If source is set to true, use defaults\n    return copy;\n  }\n\n  const storage = internals.store(source, keys); // Move shallow copy items to storage\n\n  exports.merge(copy, source, {\n    mergeArrays: false,\n    nullOverride: false\n  }); // Deep copy the rest\n\n  internals.restore(copy, source, storage); // Shallow copy the stored items and restore\n\n  return copy;\n}; // Find the common unique items in two arrays\n\n\nexports.intersect = function (array1, array2, options = {}) {\n  if (!array1 || !array2) {\n    return options.first ? null : [];\n  }\n\n  const common = [];\n  const hash = Array.isArray(array1) ? new Set(array1) : array1;\n  const found = new Set();\n\n  for (const value of array2) {\n    if (internals.has(hash, value) && !found.has(value)) {\n      if (options.first) {\n        return value;\n      }\n\n      common.push(value);\n      found.add(value);\n    }\n  }\n\n  return options.first ? null : common;\n};\n\ninternals.has = function (ref, key) {\n  if (typeof ref.has === 'function') {\n    return ref.has(key);\n  }\n\n  return ref[key] !== undefined;\n}; // Test if the reference contains the values\n\n\nexports.contain = function (ref, values, options = {}) {\n  // options: { deep, once, only, part, symbols }\n\n  /*\n      string -> string(s)\n      array -> item(s)\n      object -> key(s)\n      object -> object (key:value)\n  */\n  let valuePairs = null;\n\n  if (typeof ref === 'object' && typeof values === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {\n    valuePairs = values;\n    const symbols = Object.getOwnPropertySymbols(values).filter(Object.prototype.propertyIsEnumerable.bind(values));\n    values = [...Object.keys(values), ...symbols];\n  } else {\n    values = [].concat(values);\n  }\n\n  exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n  exports.assert(values.length, 'Values array cannot be empty');\n  let compare;\n  let compareFlags;\n\n  if (options.deep) {\n    compare = exports.deepEqual;\n    const hasOnly = options.only !== undefined;\n    const hasPart = options.part !== undefined;\n    compareFlags = {\n      prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n      part: hasOnly ? !options.only : hasPart ? options.part : false\n    };\n  } else {\n    compare = (a, b) => a === b;\n  }\n\n  let misses = false;\n  const matches = new Array(values.length);\n\n  for (let i = 0; i < matches.length; ++i) {\n    matches[i] = 0;\n  }\n\n  if (typeof ref === 'string') {\n    let pattern = '(';\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n      pattern += (i ? '|' : '') + exports.escapeRegex(value);\n    }\n\n    const regex = new RegExp(pattern + ')', 'g');\n    const leftovers = ref.replace(regex, ($0, $1) => {\n      const index = values.indexOf($1);\n      ++matches[index];\n      return ''; // Remove from string\n    });\n    misses = !!leftovers;\n  } else if (Array.isArray(ref)) {\n    const onlyOnce = !!(options.only && options.once);\n\n    if (onlyOnce && ref.length !== values.length) {\n      return false;\n    }\n\n    for (let i = 0; i < ref.length; ++i) {\n      let matched = false;\n\n      for (let j = 0; j < values.length && matched === false; ++j) {\n        if (!onlyOnce || matches[j] === 0) {\n          matched = compare(values[j], ref[i], compareFlags) && j;\n        }\n      }\n\n      if (matched !== false) {\n        ++matches[matched];\n      } else {\n        misses = true;\n      }\n    }\n  } else {\n    const keys = internals.keys(ref, options);\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const pos = values.indexOf(key);\n\n      if (pos !== -1) {\n        if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {\n          return false;\n        }\n\n        ++matches[pos];\n      } else {\n        misses = true;\n      }\n    }\n  }\n\n  if (options.only) {\n    if (misses || !options.once) {\n      return !misses;\n    }\n  }\n\n  let result = false;\n\n  for (let i = 0; i < matches.length; ++i) {\n    result = result || !!matches[i];\n\n    if (options.once && matches[i] > 1 || !options.part && !matches[i]) {\n      return false;\n    }\n  }\n\n  return result;\n}; // Flatten array\n\n\nexports.flatten = function (array, target) {\n  const result = target || [];\n\n  for (let i = 0; i < array.length; ++i) {\n    if (Array.isArray(array[i])) {\n      exports.flatten(array[i], result);\n    } else {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}; // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\n\nexports.reach = function (obj, chain, options) {\n  if (chain === false || chain === null || chain === undefined) {\n    return obj;\n  }\n\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      separator: options\n    };\n  }\n\n  const isChainArray = Array.isArray(chain);\n  exports.assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');\n  const path = isChainArray ? chain : chain.split(options.separator || '.');\n  let ref = obj;\n\n  for (let i = 0; i < path.length; ++i) {\n    let key = path[i];\n    const type = options.iterables && internals.iterables(ref);\n\n    if (Array.isArray(ref) || type === 'set') {\n      const number = Number(key);\n\n      if (Number.isInteger(number)) {\n        key = number < 0 ? ref.length + number : number;\n      }\n    }\n\n    if (!ref || typeof ref === 'function' && options.functions === false || // Defaults to true\n    !type && ref[key] === undefined) {\n      exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n      exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n      ref = options.default;\n      break;\n    }\n\n    if (!type) {\n      ref = ref[key];\n    } else if (type === 'set') {\n      ref = [...ref][key];\n    } else {\n      // type === 'map'\n      ref = ref.get(key);\n    }\n  }\n\n  return ref;\n};\n\ninternals.iterables = function (ref) {\n  if (ref instanceof Set) {\n    return 'set';\n  }\n\n  if (ref instanceof Map) {\n    return 'map';\n  }\n};\n\nexports.reachTemplate = function (obj, template, options) {\n  return template.replace(/{([^}]+)}/g, ($0, chain) => {\n    const value = exports.reach(obj, chain, options);\n    return value === undefined || value === null ? '' : value;\n  });\n};\n\nexports.assert = function (condition, ...args) {\n  if (condition) {\n    return;\n  }\n\n  if (args.length === 1 && args[0] instanceof Error) {\n    throw args[0];\n  }\n\n  throw new exports.Error(args);\n};\n\nexports.Error = class extends Error {\n  constructor(args) {\n    const msgs = args.filter(arg => arg !== '').map(arg => {\n      return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);\n    });\n    super(msgs.join(' ') || 'Unknown error');\n    Error.captureStackTrace(this, exports.assert);\n  }\n\n};\nexports.Bench = class {\n  constructor() {\n    this.ts = 0;\n    this.reset();\n  }\n\n  reset() {\n    this.ts = exports.Bench.now();\n  }\n\n  elapsed() {\n    return exports.Bench.now() - this.ts;\n  }\n\n  static now() {\n    const ts = process.hrtime();\n    return ts[0] * 1e3 + ts[1] / 1e6;\n  }\n\n}; // Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n  // Escape ^$.*+-?=!:|\\/()[]{},\n  return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n}; // Escape attribute value for use in HTTP header\n\n\nexports.escapeHeaderAttribute = function (attribute) {\n  // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n  exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n  return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"'); // Escape quotes and slash\n};\n\nexports.escapeHtml = function (string) {\n  return Escape.escapeHtml(string);\n};\n\nexports.escapeJson = function (string) {\n  return Escape.escapeJson(string);\n};\n\nexports.once = function (method) {\n  if (method._hoekOnce) {\n    return method;\n  }\n\n  let once = false;\n\n  const wrapped = function (...args) {\n    if (!once) {\n      once = true;\n      method(...args);\n    }\n  };\n\n  wrapped._hoekOnce = true;\n  return wrapped;\n};\n\nexports.ignore = function () {};\n\nexports.stringify = function (...args) {\n  try {\n    return JSON.stringify.apply(null, args);\n  } catch (err) {\n    return '[Cannot display object: ' + err.message + ']';\n  }\n};\n\nexports.wait = function (timeout) {\n  return new Promise(resolve => setTimeout(resolve, timeout));\n};\n\nexports.block = function () {\n  return new Promise(exports.ignore);\n};","map":null,"metadata":{},"sourceType":"script"}